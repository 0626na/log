# Chizzy 프로젝트
네이버 스트리밍 플랫폼 치지직의 핵심 기능인 라이브 스트리밍 기능과 실시간 채팅만 구현하는 프로젝트 입니다. 프로젝트의 기획 내용과 개발 단계를 설명 합니다.

**\[1단계: 요구사항 및 목표 재확인\]**

- 프로젝트명: **chizzy** (기존 치지직 컨셉에 기반한 간단한 라이브 스트리밍 + 실시간 채팅 MVP).
- 핵심 기능:
    1. **라이브 스트리밍**(Cloudflare 사용)
    2. **실시간 채팅**(Socket.io나 WebSocket을 통해 송수신)
- 강조 포인트:
    - Next.js(App Router) + TypeScript 조합을 사용하며, UI/UX, 반응형, 접근성, 성능 최적화 등 프론트엔드 역량 보여주기.
    - MVP 형태이지만, 이후 확장 가능성을 고려한 코드 구조와 배포 전략 마련.


---

**\[2단계: 프로젝트 개요 및 기획 방향 재정립\]**

1. **프로젝트 규모**
    
    - 완전히 새로운 라이브 스트리밍 서버를 구축하는 대신, cloudflare를 사용해 난이도를 낮춤.
    - 대신 실시간 채팅은 직접 서버를 구현(예: Node.js + Socket.io)하여 “실시간성”을 어필.
2. **프론트엔드 기술 스택**
    
    - **Next.js(App Router)**: 라우팅 구조 및 일부 SSR/SSG 기능 활용 가능.
    - **TypeScript**: 타입 안정성 확보 및 생산성 증대.
    - **UI/UX**: Tailwind CSS, Styled-components, 혹은 CSS 모듈 등 원하는 CSS 방식 선택.
    - **상태관리**: 가벼운 실시간 채팅에만 집중할 것이므로, React query 또는 Zustand/Recoil 등 중 필요 최소한을 도입.
3. **배포 전략**
    
    - 프론트엔드: **Vercel** 배포.
    - 백엔드(Socket.io 서버): **Railway** 또는 **Render**, **Fly.io** 등 Free-tier 사용.
4. **포트폴리오를 위한 문서화**
    
    - **README**에 프로젝트 개요, 기술 스택, 설치/실행 방법, 데모 링크, 시연 영상(GIF/Loom) 등을 담아 체계적 구성.
    - **기술 선택 이유**와 **향후 확장 아이디어**를 정리해 차별화 강조.

---

**\[3단계: 로드맵(구현 순서) 구체화\]**

1. **개발 환경 세팅**
    
    1. Node.js 환경 설치, 패키지 매니저(pnpm 등) 선택.
    2. `npx create-next-app@latest --experimental-app` 명령으로 Next.js(App Router) 기반 프로젝트 생성.
    3. TypeScript 설정, ESLint/Prettier 설정, GitHub 레포지토리 초기화.
2. **UI 레이아웃 뼈대 구성**
    
    4. 메인 페이지(예: `/chizzy`)에서 스트리밍 화면 + 실시간 채팅 화면을 배치.
    5. 모바일/데스크톱 뷰에 대한 반응형 레이아웃 설계. (예: 데스크톱에서는 좌측에 영상, 우측에 채팅. 모바일에서는 탭 전환.)
3. **YouTube Live 임베드**
    
    1. `iframe`을 통해 YouTube Live를 삽입하고, 적절한 반응형 스타일을 적용.
    2. 추후 다른 스트리밍 플랫폼(예: Twitch) 임베드로 확장 가능성 염두.
4. **실시간 채팅 기능**
    
    1. **백엔드(Socket.io 서버)** 구현: Node.js 기반 서버를 별도 폴더나 별도 레포지토리에 구성.
    2. 클라이언트(Next.js)와 소켓 연결 설정: `socket.io-client` 사용.
    3. 닉네임 입력 → 채팅 참여, 메시지 전송 로직 및 UI 개발.
    4. 메시지 전송 시 실시간으로 UI 갱신, 자동 스크롤(최신 메시지 표시) 구현.
5. **UI/UX 디테일 강화**
    
    1. 메시지 애니메이션(Fade-in) + 키보드 접근성(Tab, Enter) 테스트.
    2. 컬러 대비, ARIA 속성 등 접근성 점검(axe DevTools, Lighthouse).
6. **성능 및 코드 품질 관리**
    
    1. Lighthouse 통해 성능·접근성·베스트 프랙티스 점수 확인.
    2. ESLint/Prettier로 코드 일관성 유지.
    3. UI 컴포넌트 구조, 상태관리 구조 재점검(복잡도 최소화).
7. **배포 & 실제 테스트**
    
    1. **Vercel**로 프론트엔드 배포, **Railway** 등으로 Socket.io 서버 배포.
    2. 실제 배포 URL에서 소켓 연결, 채팅 메시지 송수신, 반응형 동작 여부 확인.
    3. 성능 리포트, 반응형 캡처, 접근성 테스트 결과 등을 문서화.
8. **문서화 & 포트폴리오 작업**
    
    4. GitHub에 **README** 정리: 프로젝트 개요, 기술 스택, 아키텍처 다이어그램, 설치/실행 가이드, 데모 링크, 시연 영상(GIF/Loom).
    5. 이슈 트래킹, 커밋 기록 등을 간결하게 정리해 “협업 가능성”도 강조 가능.
    6. “향후 확장성” 섹션 추가(인증, WebRTC 직접 구현, Storybook, Server Actions 적용 등).

---

**\[4단계: 프로젝트를 통해 보여줄 수 있는 역량\]**

1. **프론트엔드 아키텍처 설계**
    
    - Next.js(App Router)로 페이지 구조를 잡고, 클라이언트/서버 렌더링 방식을 적절히 사용.
    - TypeScript로 타입 안전성을 확보해 유지보수성 향상.
2. **실시간성 처리 경험**
    
    - Socket.io나 WebSocket을 직접 설정하고, 실시간 채팅과 소켓 이벤트 핸들링을 구현할 수 있음을 어필.
3. **UI/UX & 접근성**
    
    - 반응형 레이아웃, 키보드 접근, 명확한 색상 대비, ARIA 라벨 등의 적용 사례로 사용자 경험을 높임.
    - 작은 디테일(메시지 애니메이션, 자동 스크롤 등)로도 완성도 어필 가능.
4. **성능 최적화 및 배포**
    
    - Lighthouse, ESLint, Prettier, 코드 스플리팅 등으로 안정된 웹 애플리케이션 제공 가능성을 시연.
    - Vercel, Railway 등 PaaS 사용 경험 → 배포 자동화 파이프라인, 실제 운영 환경에서의 테스트 능력 과시.
5. **문서화 및 협업 능력**
    
    - GitHub 프로젝트 구조, README, 커밋 메시지, 기술적 의사결정 근거 정리.
    - 추후 팀 프로젝트에도 응용 가능함을 보여줌.

---

**\[5단계: 마무리 및 향후 개선\]**

- 사용자 인증, 채팅 관리 기능(쪽지, 밴 처리 등), 멀티 룸 채팅 기능 도입으로 실제 서비스와 유사하게 발전 가능.
- UI 컴포넌트 스토리북(Storybook)화, 서버 액션(Server Actions) 기능을 통한 SSR 강화, GraphQL을 통한 데이터 통합 등 다양한 확장 시나리오 존재.