> 이글은 chat gpt o3-mini 모델이 번역한 공식문서 내용입니다. 오직 학습의 목적을 위한 것입니다.

아래는 React 공식문서 “Keeping Components Pure”에 대한 내용을, 리액트를 처음 배우는 개발자도 쉽게 이해할 수 있도록 자연스러운 한국어로 번역한 전자책 스타일의 문서입니다.

---

# 컴포넌트를 순수하게 유지하기

일부 JavaScript 함수는 **순수 함수**입니다. 순수 함수는 오직 계산만 수행하고 그 외에는 아무 것도 하지 않습니다. 컴포넌트를 오직 순수 함수로만 작성한다면, 코드베이스가 커질 때 발생할 수 있는 당황스러운 버그들과 예측 불가능한 동작들을 피할 수 있습니다. 하지만 이러한 이점을 얻으려면 몇 가지 규칙을 반드시 따라야 합니다.

### 학습 목표

- **순수함(purity)** 이 무엇이며, 왜 버그를 예방하는 데 도움이 되는지 이해하기
- 렌더링 단계에서 변경 사항을 배제하여 컴포넌트를 순수하게 유지하는 방법 익히기
- 컴포넌트의 실수를 찾아내기 위해 **Strict Mode**를 활용하는 방법 배우기

---

## 순수함: 컴포넌트를 수식처럼 다루기

컴퓨터 과학, 특히 함수형 프로그래밍 분야에서는 [순수 함수](https://wikipedia.org/wiki/Pure_function)란 다음과 같은 특성을 가진 함수입니다.

- **자신의 일만 한다.**  
    호출되기 전에 존재하던 객체나 변수를 변경하지 않습니다.
- **동일한 입력에는 항상 동일한 출력.**  
    같은 입력을 주면 순수 함수는 항상 같은 결과를 반환해야 합니다.

이미 수학의 수식을 예로 들어 순수 함수의 개념을 익혀봤을 것입니다.

예를 들어, 수학 수식 **y = 2x**를 생각해 봅시다.

- x가 2라면, y는 항상 4입니다.
- x가 3이라면, y는 항상 6입니다.

즉, x가 3일 때 y가 시간대나 주식시장 상황에 따라 9, –1, 또는 2.5가 되는 일은 결코 없습니다.  
수학 수식처럼, x가 3이면 y는 **반드시** 6이 되어야 합니다.

이 개념을 JavaScript 함수로 표현하면 다음과 같습니다:

```jsx
function double(number) {
  return 2 * number;
}
```

위의 예에서 `double` 함수는 **순수 함수**입니다. 만약 3을 전달하면, 언제나 6을 반환합니다.

React는 이러한 개념을 중심으로 설계되었습니다. **React는 여러분이 작성하는 모든 컴포넌트가 순수 함수라고 가정합니다.**  
즉, 작성한 React 컴포넌트는 동일한 입력이 주어지면 항상 같은 JSX를 반환해야 합니다:

```jsx
//App.js
function Recipe({ drinkers }) {
  return (
    <ol>    
      <li>Boil {drinkers} cups of water.</li>
      <li>Add {drinkers} spoons of tea and {0.5 * drinkers} spoons of spice.</li>
      <li>Add {0.5 * drinkers} cups of milk to boil and sugar to taste.</li>
    </ol>
  );
}

export default function App() {
  return (
    <section>
      <h1>Spiced Chai Recipe</h1>
      <h2>For two</h2>
      <Recipe drinkers={2} />
      <h2>For a gathering</h2>
      <Recipe drinkers={4} />
    </section>
  );
}
```

예를 들어, `Recipe` 컴포넌트에 `drinkers={2}`를 전달하면 항상 “2 cups of water”를 포함하는 JSX를 반환합니다. 마찬가지로, `drinkers={4}`를 전달하면 “4 cups of water”를 반환합니다.  
이 방식은 수학의 수식처럼 일정한 규칙에 따라 작동합니다.

여러분은 컴포넌트를 요리법(recipe)으로 생각할 수 있습니다. 요리법을 그대로 따르고 요리 도중 새로운 재료를 추가하지 않는다면 매번 같은 요리가 완성되듯, 컴포넌트가 반환하는 “요리”, 즉 JSX 역시 항상 동일하게 만들어집니다.

![A tea recipe for x people: take x cups of water, add x spoons of tea and 0.5x spoons of spices, and 0.5x cups of milk](https://react.dev/images/docs/illustrations/i_puritea-recipe.png)

_Illustrated by [Rachel Lee Nabors](https://nearestnabors.com/)_

---

## 부수 효과: 의도하지 않은 결과

React의 렌더링 과정은 항상 순수해야 합니다. 컴포넌트는 JSX를 **반환**만 해야 하며, 렌더링 이전에 존재했던 객체나 변수를 **변경**해서는 안 됩니다. 만약 그렇게 된다면 컴포넌트는 순수하지 않은(impure) 컴포넌트가 되어 버립니다.

아래 예제는 이러한 규칙을 어기는 컴포넌트를 보여줍니다:

```jsx
//App.js
let guest = 0;

function Cup() {
  // 나쁜 예: 이미 존재하는 변수를 변경하고 있음!
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}
```

위 컴포넌트는 컴포넌트 외부에 선언된 `guest` 변수를 읽고 수정합니다. 이로 인해 **동일한 컴포넌트를 여러 번 호출할 경우, 매번 다른 JSX가 생성**됩니다. 게다가 다른 컴포넌트가 이 `guest` 변수를 읽게 되면, 렌더링 시점에 따라 결과가 달라지므로 예측할 수 없게 됩니다.

수학 수식 **y = 2x**로 돌아가 보겠습니다. 만약 x가 2여도 y가 항상 4라는 보장이 없게 되는 것입니다. 테스트는 실패하고 사용자들은 당황하게 될 수 있습니다. 실제로는 이런 방식으로 버그가 발생할 위험이 큽니다.

이 문제는 `guest` 값을 prop으로 전달하여 해결할 수 있습니다:

```jsx
//App.js
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup guest={1} />
      <Cup guest={2} />
      <Cup guest={3} />
    </>
  );
}
```

이제 컴포넌트는 prop에 의존하여 순수하게 동작합니다.

일반적으로 컴포넌트가 특정 순서대로 렌더링된다고 기대해서는 안 됩니다. 수학에서 **y = 2x**를 계산하는 순서가 앞이든 뒤이든 상관없듯, 각 컴포넌트는 스스로 독립적으로 JSX를 계산해야 합니다. 렌더링은 마치 학교 시험과도 같아서, 각 컴포넌트가 자기 스스로 문제를 풀어내야 합니다.

---

### 깊이 있게 알아보기

#### Strict Mode로 순수하지 않은 계산 감지하기

React에서는 렌더링 중 읽을 수 있는 입력값이 세 가지 있습니다: [props](https://react.dev/learn/passing-props-to-a-component), [state](https://react.dev/learn/state-a-components-memory), 그리고 [context](https://react.dev/learn/passing-data-deeply-with-context). 이 입력값들은 항상 읽기 전용으로 다뤄야 합니다.

사용자 입력에 반응하여 뭔가를 **변경**하고자 한다면, 변수를 직접 수정하는 대신 [state를 설정](https://react.dev/learn/state-a-components-memory)해야 합니다. 렌더링 도중에 이미 존재하는 변수나 객체를 변경해서는 안 됩니다.

React는 개발 모드에서 각 컴포넌트의 함수를 두 번 호출하는 **Strict Mode**를 제공합니다. **컴포넌트 함수를 두 번 호출함으로써, Strict Mode는 규칙을 위반한 컴포넌트를 찾아낼 수 있도록 도와줍니다.**

예를 들어, 원래의 예제는 “Guest #2”, “Guest #4”, “Guest #6”과 같이 표시되었는데, 이는 원래의 함수가 순수하지 않아 두 번 호출되면서 값이 누적되었기 때문입니다. 반면, 순수한 버전은 함수를 두 번 호출해도 같은 결과를 반환합니다. 순수 함수는 단지 계산만 수행하므로, 두 번 호출해도 결과에 변화가 없습니다—항상 같은 입력에는 같은 출력을 제공합니다.

Strict Mode는 실제 배포 환경에서는 영향을 주지 않으므로, 사용자에게 앱의 속도를 저하시키지 않습니다. Strict Mode를 사용하려면, 최상위 컴포넌트를 `<React.StrictMode>`로 감싸면 됩니다. 일부 프레임워크는 기본적으로 이 설정을 적용합니다.

다음은 Strict Mode가 적용된 예제 코드입니다:

```jsx
//App.js
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaGathering() {
  let cups = [];
  for (let i = 1; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />);
  }
  return cups;
}
```

여기서 주의할 점은, 만약 `cups` 변수나 `[]` 배열이 `TeaGathering` 함수 밖에서 생성되었다면 큰 문제가 발생했을 것입니다. 그 경우 이미 존재하는 객체에 새로운 요소들을 추가하게 되어 순수성이 깨지게 됩니다.  
하지만 위 예제에서는 `TeaGathering` 내부에서 동일한 렌더링 과정 중에 배열과 변수를 생성했기 때문에, 외부 코드에서는 이러한 변경 사실을 알 수 없습니다. 이것을 **“지역적 변이(local mutation)”**라고 부르며, 컴포넌트의 작은 비밀과도 같습니다.

---

## 부수 효과를 발생시켜도 되는 경우

함수형 프로그래밍은 순수함에 크게 의존하지만, 프로그래밍의 본질은 어딘가에서 **변화**가 필요하다는 점에 있습니다. 화면을 업데이트하거나, 애니메이션을 시작하거나, 데이터를 변경하는 등의 변화—이를 **부수 효과(side effects)**라고 합니다. 부수 효과는 렌더링 과정 중이 아니라 그 **“부수적으로”** 발생하는 작업입니다.

React에서 부수 효과는 주로 [이벤트 핸들러](https://react.dev/learn/responding-to-events) 내부에서 수행됩니다. 이벤트 핸들러는 사용자가 버튼을 클릭하는 등의 행동을 했을 때 React가 실행하는 함수입니다. 이 핸들러들은 컴포넌트 내부에 정의되어 있지만, 렌더링 과정에서는 실행되지 않으므로 순수할 필요가 없습니다.

만약 적절한 이벤트 핸들러를 찾지 못한다면, 컴포넌트 내에서 [`useEffect`](https://react.dev/reference/react/useEffect)를 사용하여 JSX에 부수 효과를 붙일 수 있습니다. 다만, 이 방법은 최후의 수단으로 사용하는 것이 좋습니다.

가능하다면 로직을 렌더링만으로 표현해 보세요. 그러면 얼마나 많은 문제를 자연스럽게 해결할 수 있는지 놀라게 될 것입니다!

---

### 깊이 있게 알아보기

#### 왜 React는 순수함을 중요하게 여길까요?

순수 함수를 작성하는 것은 어느 정도의 연습과 규율이 필요하지만, 다음과 같은 놀라운 기회를 제공합니다:

- **다양한 환경에서 실행 가능:**  
    컴포넌트는 동일한 입력에 대해 항상 같은 결과를 반환하므로, 서버와 같은 다른 환경에서도 실행할 수 있습니다. 한 컴포넌트가 여러 사용자 요청에 대해 동일한 결과를 낼 수 있는 것입니다.
- **성능 최적화:**  
    입력값이 변경되지 않은 컴포넌트의 렌더링을 건너뛸 수 있습니다. 순수 함수는 항상 같은 결과를 반환하기 때문에 캐시하여 안전하게 재사용할 수 있습니다.
- **안정적인 렌더링 중단:**  
    깊은 컴포넌트 트리의 중간에 데이터가 변경되더라도, React는 낡은 렌더링을 끝까지 수행하지 않고 렌더링을 재시작할 수 있습니다. 순수함 덕분에 계산을 언제든 중단하는 것이 안전해집니다.

React가 새롭게 도입하는 모든 기능들은 순수함의 이점을 활용합니다. 데이터 패칭, 애니메이션, 성능 개선 등 모든 면에서 컴포넌트를 순수하게 유지하는 것이 React 패러다임의 강력한 힘을 발휘하게 합니다.

---

## 요약

- **컴포넌트는 순수해야 합니다.**
    - **자신의 일만 수행:** 렌더링 전에 존재하던 객체나 변수를 변경해서는 안 됩니다.
    - **동일한 입력에는 동일한 출력:** 같은 입력을 주면 항상 같은 JSX를 반환해야 합니다.
- 렌더링은 언제든 발생할 수 있으므로, 컴포넌트 간의 렌더링 순서에 의존해서는 안 됩니다.
- 렌더링에 사용되는 입력값들(즉, props, state, context)은 절대로 직접 변경(변이)해서는 안 됩니다. 화면을 업데이트할 때는 기존 객체를 변경하는 대신 “state를 설정”해야 합니다.
- 컴포넌트의 로직은 반환하는 JSX 안에 표현하려고 노력하세요. 만약 무언가를 변경해야 한다면, 보통은 이벤트 핸들러에서 처리해야 하며, 최후의 수단으로 `useEffect`를 사용할 수 있습니다.
- 순수 함수를 작성하는 데는 약간의 연습이 필요하지만, 이를 통해 React 패러다임의 강력한 기능들을 누릴 수 있습니다.

---

이상으로 React 공식문서 “컴포넌트를 순수하게 유지하기”의 내용을 번역해 보았습니다. 혹시 추가적으로 궁금한 부분이나 더 설명이 필요한 내용이 있다면 언제든지 질문해 주세요.

#react #공식문서 