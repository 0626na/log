# Two Pointers

데이터 구조내의 데이터를 특정 조건에 맞춰서 탐색 및 조작하는 알고리즘. 두개의 포인터를 가지고 조작하기에 투 포인터 알고리즘이라 한다.
조건에 따라서 포인터를 움직여 원하는 데이터를 탐색해가는 방식입니다.

## 효율성

- 시간복잡도가 O(n)
- 루프문을 여러개 사용할 필요가 없다.
- 탐색하는 리스트 외에 다른 공간을 쓰지 않아서 공간 효율성이 높다.

## 주로 사용하는 경우

- 정렬된 배열에서의 합 탐색
- string, 배열의 특정 패턴 탐색
- 두 배열간의 병합

## 동작 방식

투포인터는 일반적으로 두가지 방식으로 동작합니다.

### 좌우 포인터 (Left and Right Pointers)

배열의 시작과 끝에서 각각 포인터들이 시작하여 교차하는 지점까지 하나씩 이동하면서 탐색하는 방식입니다. Left 포인터는 오른쪽으로, Right 포인터는 왼쪽으로 하나씩 이동하면서 탐색하며 서로 교차되는 지점에서 멈춥니다. 예시로 어떤 배열에서 두수의 합을 찾는경우를 가정합니다.

상황: 정렬된 배열 nums에서 target이 주어질때 배열 내에서 두개의 합이 target이 되는 두수의 인덱스를 찾는다.

1. 포인터 설정
   먼저 배열의 처음인 left 포인터를 설정하고 시작인덱스인 0을 초기화, right 포인터를 설정하여 배열의 마지막 인덱스로 초기화를 합니다.
2. 포인터 이동
   nums[left], nums[right]의 합을 계산합니다. target 보다 작으면 더 큰 합을 얻기위해 left를 오른쪽으로 한칸 이동합니다. target보다 크면 더 작은 합을 얻기위해 right 포인터를 왼쪽으로 한칸 이동합니다.
   그렇게 left와 right를 조건에 맞춰 이동하면서 target과 일치하는 합을 찾습니다.

아래는 위에 Two pointers 방식을 코드로 작성한 것입니다.

```python
def two_sum_sorted(nums, target):
    left = 0
    right = len(nums) - 1

    while left < right:
        current_sum = nums[left] + nums[right]

        if current_sum == target:
            return (left, right)
        elif current_sum < target:
            left += 1
        else:
            right -= 1

    return None

# 테스트
nums = [1, 2, 3, 4, 6]
target = 6
print(two_sum_sorted(nums, target))  # 출력: (1, 3) -> 2 + 4 = 6
```

## 투 포인터 알고리즘의 장단점

### 장점

1. 시간 효율성
   대부분의 경우에 포인터 두개를 가지고 한번의 루프로 해결이 가능하여 시간 복잡도가 낮다.

2. 공간 효율성
   주어진 배열 외에 추가적인 공간을 쓰지않아서 공간복잡도가 낮다.

3. 코드 간결함
   크게 복잡한 것 없이 문제를 해결할수 있습니다.

### 단점

1. 포인터 관리
   포인터를 조건에 따라서 정확하게 설정해야 합니다. 잘못 설정하면 에러가 발생하거나 원하는 값을 얻지 못합니다

2. 문제에 따라 적용 못하는 경우
   배열을 이용한 문제에서 모든 경우에 투 포인터 알고리즘을 적용 할수는 없습니다.

## 투 포인터 사용시 주의점

1. 포인터 초기 위치설정
   문제에 맞게 초기화를 해야합니다. 배열의 처음과 끝에서 시작할지, 아니면 다른 조건이 있는지를 잘 확인해야 합니다.
2. 포인터 이동조건
   포인터를 언제 어떻게 이동할지 조건이 명확해야 합니다. 이동이 잘못될 경우 올바른 데이터를 얻지 못합니다
3. 중복처리
   중복되는 요소가 있을경우 이를 처리하는 로직이 필요합니다. 만약 유일한 조합을 원하는 경우라고 한다면 중복될때 건너뛰는 로직이 필요합니다.
4. 경계처리
   포인터가 배열의 범위를 벗어나서는 안됩니다. 배열을 벗어나는 경우를 설정해야합니다.
