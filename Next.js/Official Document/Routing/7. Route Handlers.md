> 이 글은 chat gpt o3 mini 모델로 번역한 Next.js 공식문서 입니다. 오직 개인의 학습을 위함이 목적입니다.

아래는 Next.js 공식문서의 "Route Handlers" 내용을 전자책 형식으로, Next.js를 처음 배우는 개발자도 쉽게 이해할 수 있도록 자연스러운 한국어로 번역한 것입니다. 모든 내용과 예제, 링크, 이미지를 원문 그대로 반영하였으니 참고하시기 바랍니다.

---

# Next.js 공식문서 – Route Handlers

Next.js에서는 **Route Handlers**를 사용하여 Web [Request](https://developer.mozilla.org/docs/Web/API/Request)와 [Response](https://developer.mozilla.org/docs/Web/API/Response) API를 기반으로 특정 라우트에 대한 사용자 정의 요청 핸들러를 만들 수 있습니다.

![Route.js Special File](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Froute-special-file.png&w=3840&q=75)

> **알아두면 좋은 점**: 라우트 핸들러는 오직 `app` 디렉토리 내부에서만 사용 가능합니다. 이는 `pages` 디렉토리 내부의 [API Routes](https://nextjs.org/docs/pages/building-your-application/routing/api-routes)와 동일한 기능을 수행하므로, API Routes와 라우트 핸들러를 함께 사용할 필요가 없습니다.

---

## 1. 컨벤션 (Convention)

라우트 핸들러는 `app` 디렉토리 내부에 위치한 [`route.js|ts` 파일](https://nextjs.org/docs/app/api-reference/file-conventions/route)로 정의합니다:

```tsx
//app/api/route.ts
export async function GET(request: Request) {}
```

라우트 핸들러는 `page.js`나 `layout.js`와 마찬가지로 `app` 디렉토리 어디에나 중첩해서 배치할 수 있습니다. 단, 동일한 라우트 세그먼트에 `page.js`와 함께 `route.js` 파일이 존재할 수는 없습니다.

---

## 2. 지원되는 HTTP 메소드 (Supported HTTP Methods)

다음의 [HTTP 메소드](https://developer.mozilla.org/docs/Web/HTTP/Methods)가 지원됩니다:  
`GET`, `POST`, `PUT`, `PATCH`, `DELETE`, `HEAD`, `OPTIONS`.

만약 지원되지 않는 메소드가 호출된다면, Next.js는 `405 Method Not Allowed` 응답을 반환합니다.

---

## 3. 확장된 NextRequest 및 NextResponse API (Extended NextRequest and NextResponse APIs)

Next.js는 기본 제공 [Request](https://developer.mozilla.org/docs/Web/API/Request)와 [Response](https://developer.mozilla.org/docs/Web/API/Response) API를 지원할 뿐만 아니라,  
[`NextRequest`](https://nextjs.org/docs/app/api-reference/functions/next-request)와  
[`NextResponse`](https://nextjs.org/docs/app/api-reference/functions/next-response)를 확장하여 고급 사용 사례에 유용한 헬퍼 함수를 제공합니다.

---

## 4. 동작 (Behavior)

### 4.1 캐싱 (Caching)

라우트 핸들러는 기본적으로 캐싱되지 않습니다.  
다만, `GET` 메소드에 한해 캐싱을 선택적으로 적용할 수 있습니다. 다른 지원 HTTP 메소드는 **캐싱되지 않습니다**.  
`GET` 메소드를 캐싱하려면, 라우트 핸들러 파일 내에서 아래와 같이 [라우트 구성 옵션](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#dynamic) (예: `export const dynamic = 'force-static'`)을 사용하면 됩니다.

```tsx
//app/items/route.ts
export const dynamic = 'force-static'
 
export async function GET() {
  const res = await fetch('https://data.mongodb-api.com/...', {
    headers: {
      'Content-Type': 'application/json',
      'API-Key': process.env.DATA_API_KEY,
    },
  })
  const data = await res.json()
 
  return Response.json({ data })
}
```

> **알아두면 좋은 점**: 캐시되는 `GET` 메소드와 동일한 파일 내에 있더라도, 다른 지원 HTTP 메소드는 **캐싱되지 않습니다**.

---

## 5. 특수 라우트 핸들러 (Special Route Handlers)

[`sitemap.ts`](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/sitemap),  
[`opengraph-image.tsx`](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image),  
[`icon.tsx`](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/app-icons) 등과 기타 [메타데이터 파일](https://nextjs.org/docs/app/api-reference/file-conventions/metadata)은  
동적 API나 동적 구성 옵션을 사용하지 않는 한 기본적으로 정적(static)으로 유지됩니다.

---

## 6. 라우트 해석 (Route Resolution)

라우트는 가장 하위 수준의 라우팅 기본 요소라고 볼 수 있습니다.

- 라우트는 `page`처럼 레이아웃이나 클라이언트 사이드 네비게이션에 참여하지 않습니다.
- `page.js`와 동일한 라우트에 `route.js` 파일이 존재할 수 없습니다.

아래 표는 각각의 경우에 대한 결과를 보여줍니다.

|페이지|라우트|결과|
|---|---|---|
|`app/page.js`|`app/route.js`|Conflict|
|`app/page.js`|`app/api/route.js`|Valid|
|`app/[user]/page.js`|`app/api/route.js`|Valid|

각 `route.js`나 `page.js` 파일은 해당 라우트에 대한 모든 HTTP 메소드를 담당하게 됩니다.

```tsx
//app/page.ts
export default function Page() {
  return <h1>Hello, Next.js!</h1>
}
 
// ❌ Conflict
// `app/route.ts`
export async function POST(request: Request) {}
```

---

## 7. 예시 (Examples)

다음 예시들은 라우트 핸들러를 다른 Next.js API 및 기능과 결합하는 방법을 보여줍니다.

### 7.1 캐시된 데이터 재검증 (Revalidating Cached Data)

증분 정적 재생성(Incremental Static Regeneration, ISR)을 사용하여 [캐시된 데이터를 재검증](https://nextjs.org/docs/app/building-your-application/data-fetching/incremental-static-regeneration)할 수 있습니다:

```tsx
//app/posts/route.ts
export const revalidate = 60
 
export async function GET() {
  const data = await fetch('https://api.vercel.app/blog')
  const posts = await data.json()
 
  return Response.json(posts)
}
```

### 7.2 쿠키 (Cookies)

`next/headers`의 [`cookies`](https://nextjs.org/docs/app/api-reference/functions/cookies)를 사용하여 쿠키를 읽거나 설정할 수 있습니다.  
이 서버 함수는 라우트 핸들러 내에서 직접 호출하거나 다른 함수 내부에 중첩하여 사용할 수 있습니다.

또한, [`Set-Cookie`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Set-Cookie) 헤더를 사용하여 새로운 `Response`를 반환할 수도 있습니다.

```tsx
//app/api/route.ts
import { cookies } from 'next/headers'
 
export async function GET(request: Request) {
  const cookieStore = await cookies()
  const token = cookieStore.get('token')
 
  return new Response('Hello, Next.js!', {
    status: 200,
    headers: { 'Set-Cookie': `token=${token.value}` },
  })
}
```

또한, 기본 Web API를 사용하여 요청으로부터 쿠키를 읽을 수도 있습니다 ([`NextRequest`](https://nextjs.org/docs/app/api-reference/functions/next-request)):

```tsx
//app/api/route.ts
import { type NextRequest } from 'next/server'
 
export async function GET(request: NextRequest) {
  const token = request.cookies.get('token')
}
```

### 7.3 헤더 (Headers)

`next/headers`의 [`headers`](https://nextjs.org/docs/app/api-reference/functions/headers)를 사용하여 헤더를 읽을 수 있습니다.  
이 서버 함수는 라우트 핸들러 내에서 직접 호출하거나 다른 함수 내부에 중첩하여 사용할 수 있습니다.

해당 `headers` 인스턴스는 읽기 전용이므로, 헤더를 설정하려면 새로운 헤더와 함께 새로운 `Response`를 반환해야 합니다.

```tsx
//app/api/route.ts
import { headers } from 'next/headers'
 
export async function GET(request: Request) {
  const headersList = await headers()
  const referer = headersList.get('referer')
 
  return new Response('Hello, Next.js!', {
    status: 200,
    headers: { referer: referer },
  })
}
```

또한, 기본 Web API를 사용하여 요청으로부터 헤더를 읽을 수도 있습니다 ([`NextRequest`](https://nextjs.org/docs/app/api-reference/functions/next-request)):

```tsx
//app/api/route.ts
import { type NextRequest } from 'next/server'
 
export async function GET(request: NextRequest) {
  const requestHeaders = new Headers(request.headers)
}
```

### 7.4 리다이렉트 (Redirects)

다음과 같이 `next/navigation`의 `redirect` 함수를 사용하여 리다이렉트를 수행할 수 있습니다:

```tsx
//app/api/route.ts
import { redirect } from 'next/navigation'
 
export async function GET(request: Request) {
  redirect('https://nextjs.org/')
}
```

### 7.5 동적 라우트 세그먼트 (Dynamic Route Segments)

라우트 핸들러는 [동적 세그먼트](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes)를 사용하여 동적 데이터를 기반으로 요청 핸들러를 생성할 수 있습니다.

```tsx
//app/items/[slug]/route.ts
export async function GET(
  request: Request,
  { params }: { params: Promise<{ slug: string }> }
) {
  const slug = (await params).slug // 'a', 'b', 또는 'c'
}
```

|Route|Example URL|`params`|
|---|---|---|
|`app/items/[slug]/route.js`|`/items/a`|`Promise<{ slug: 'a' }>`|
|`app/items/[slug]/route.js`|`/items/b`|`Promise<{ slug: 'b' }>`|
|`app/items/[slug]/route.js`|`/items/c`|`Promise<{ slug: 'c' }>`|

### 7.6 URL 쿼리 파라미터 (URL Query Parameters)

라우트 핸들러에 전달되는 요청 객체는 `NextRequest` 인스턴스이며,  
쿼리 파라미터를 보다 쉽게 처리할 수 있는 [추가적인 편의 메소드들](https://nextjs.org/docs/app/api-reference/functions/next-request#nexturl)을 포함하고 있습니다.

```tsx
//app/api/search/route.ts
import { type NextRequest } from 'next/server'
 
export function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams
  const query = searchParams.get('query')
  // /api/search?query=hello 에서 query는 "hello" 입니다.
}
```

### 7.7 스트리밍 (Streaming)

스트리밍은 OpenAI와 같은 대형 언어 모델(LLMs)과 결합하여 AI가 생성한 콘텐츠를 제공할 때 흔히 사용됩니다.  
자세한 내용은 [AI SDK](https://sdk.vercel.ai/docs/introduction)를 참고하세요.

```tsx
//app/api/chat/route.ts
import { openai } from '@ai-sdk/openai'
import { StreamingTextResponse, streamText } from 'ai'
 
export async function POST(req: Request) {
  const { messages } = await req.json()
  const result = await streamText({
    model: openai('gpt-4-turbo'),
    messages,
  })
 
  return new StreamingTextResponse(result.toAIStream())
}
```

이러한 추상화는 Web API를 사용하여 스트림(stream)을 생성합니다.  
또한, 기본 Web API를 직접 사용하여 스트림을 생성할 수도 있습니다.

```tsx
//app/api/route.ts

// https://developer.mozilla.org/docs/Web/API/ReadableStream#convert_async_iterator_to_stream
function iteratorToStream(iterator: any) {
  return new ReadableStream({
    async pull(controller) {
      const { value, done } = await iterator.next()
 
      if (done) {
        controller.close()
      } else {
        controller.enqueue(value)
      }
    },
  })
}
 
function sleep(time: number) {
  return new Promise((resolve) => {
    setTimeout(resolve, time)
  })
}
 
const encoder = new TextEncoder()
 
async function* makeIterator() {
  yield encoder.encode('<p>One</p>')
  await sleep(200)
  yield encoder.encode('<p>Two</p>')
  await sleep(200)
  yield encoder.encode('<p>Three</p>')
}
 
export async function GET() {
  const iterator = makeIterator()
  const stream = iteratorToStream(iterator)
 
  return new Response(stream)
}
```

### 7.8 요청 본문 (Request Body)

표준 Web API 메소드를 사용하여 `Request`의 본문을 읽을 수 있습니다:

```tsx
//app/items/route.ts
export async function POST(request: Request) {
  const res = await request.json()
  return Response.json({ res })
}
```

### 7.9 요청 본문 – FormData (Request Body FormData)

`request.formData()` 함수를 사용하여 `FormData`를 읽을 수 있습니다:

```tsx
//app/items/route.ts
export async function POST(request: Request) {
  const formData = await request.formData()
  const name = formData.get('name')
  const email = formData.get('email')
  return Response.json({ name, email })
}
```

FormData의 데이터는 모두 문자열이므로,  
요청을 검증하고 원하는 형식(예: 숫자)으로 데이터를 가져오기 위해 [`zod-form-data`](https://www.npmjs.com/zod-form-data)를 사용할 수 있습니다.

### 7.10 CORS

표준 Web API 메소드를 사용하여 특정 라우트 핸들러에 대해 CORS 헤더를 설정할 수 있습니다:

```tsx
//app/api/route.ts
export async function GET(request: Request) {
  return new Response('Hello, Next.js!', {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  })
}
```

> **알아두면 좋은 점**:
> 
> - 여러 라우트 핸들러에 CORS 헤더를 추가하려면 [미들웨어](https://nextjs.org/docs/app/building-your-application/routing/middleware#cors) 또는 [`next.config.js` 파일](https://nextjs.org/docs/app/api-reference/config/next-config-js/headers#cors)을 사용할 수 있습니다.
> - 또는, [CORS 예시](https://github.com/vercel/examples/blob/main/edge-functions/cors/lib/cors.ts) 패키지를 참고하세요.

### 7.11 웹훅 (Webhooks)

라우트 핸들러를 사용하여 서드파티 서비스로부터 웹훅을 받을 수 있습니다:

```tsx
//app/api/route.ts
export async function POST(request: Request) {
  try {
    const text = await request.text()
    // 웹훅 페이로드 처리
  } catch (error) {
    return new Response(`Webhook error: ${error.message}`, {
      status: 400,
    })
  }
 
  return new Response('Success!', {
    status: 200,
  })
}
```

특히, Pages 라우터의 API Routes와는 달리 추가 구성을 위해 `bodyParser`를 사용할 필요가 없습니다.

### 7.12 UI 이외의 응답 (Non-UI Responses)

라우트 핸들러를 사용하여 UI가 아닌 콘텐츠를 반환할 수 있습니다.  
예를 들어, [`sitemap.xml`](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/sitemap#generating-a-sitemap-using-code-js-ts),  
[`robots.txt`](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/robots#generate-a-robots-file),  
[`app icons`](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/app-icons#generate-icons-using-code-js-ts-tsx),  
[open graph images](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image) 등은 모두 내장된 지원을 받습니다.

```tsx
//app/rss.xml/route.ts
export async function GET() {
  return new Response(
    `<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
 
<channel>
  <title>Next.js Documentation</title>
  <link>https://nextjs.org/docs</link>
  <description>The React Framework for the Web</description>
</channel>
 
</rss>`,
    {
      headers: {
        'Content-Type': 'text/xml',
      },
    }
  )
}
```

### 7.13 세그먼트 구성 옵션 (Segment Config Options)

라우트 핸들러는 페이지와 레이아웃과 동일한 [라우트 세그먼트 구성 옵션](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config)을 사용합니다:

```tsx
//app/items/route.ts
export const dynamic = 'auto'
export const dynamicParams = true
export const revalidate = false
export const fetchCache = 'auto'
export const runtime = 'nodejs'
export const preferredRegion = 'auto'
```

---

## 8. API 레퍼런스 (API Reference)

route.js 특수 파일에 대한 API 레퍼런스를 확인해보세요.

### [route.js](https://nextjs.org/docs/app/api-reference/file-conventions/route)

이 파일은 Next.js에서 라우트 핸들러를 구현할 때 사용되는 특수 파일에 대한 API 참고문서입니다.

---

이상으로 Next.js의 Route Handlers에 관한 공식문서 내용을 자세하게 번역하여 정리해보았습니다.  
혹시 이해되지 않거나 추가적인 설명이 필요한 부분이 있다면, 솔직하게 제가 모르는 부분이라고 말씀드릴 수 있지만, 이번 내용은 공식문서의 내용을 충실하게 반영한 것으로 모든 세부 사항을 포함하고 있습니다.

Next.js 학습에 큰 도움이 되시길 바랍니다.  
Next.js 분야의 최고 전문가 지피였습니다.

#nextJS #공식문서 