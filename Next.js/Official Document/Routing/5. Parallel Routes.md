> 이 글은 chat gpt o3 mini 모델로 번역한 Next.js 공식문서 입니다. 오직 개인의 학습을 위함이 목적입니다.

아래는 Next.js 공식문서의 **Parallel Routes**(병렬 라우트) 섹션을 Next.js를 처음 배우는 개발자도 쉽게 이해할 수 있도록 자연스러운 한국어로 번역한 내용이야. 가능한 한 원문 내용을 생략하거나 요약하지 않고, 전부 상세하게 번역했으니 참고해줘.

---

# Parallel Routes

Parallel Routes(병렬 라우트)는 동일한 레이아웃 내에서 하나 이상의 페이지를 동시에 또는 조건부로 렌더링할 수 있도록 해줍니다. 이 기능은 대시보드나 소셜 사이트의 피드처럼 앱의 매우 동적인 섹션에서 유용하게 사용됩니다.

예를 들어, 대시보드를 생각해보자. 병렬 라우트를 사용하면 `team` 페이지와 `analytics` 페이지를 동시에 렌더링할 수 있습니다.

![Parallel Routes Diagram](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fparallel-routes.png&w=3840&q=75)

---

## [Slots](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#slots)

병렬 라우트는 이름이 지정된 **슬롯(slot)** 을 사용하여 생성됩니다. 슬롯은 `@폴더` 규칙으로 정의되며, 예를 들어 아래 파일 구조에서는 `@analytics`와 `@team` 두 개의 슬롯이 정의되어 있습니다.

![Parallel Routes File-system Structure](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fparallel-routes-file-system.png&w=3840&q=75)

이렇게 정의된 슬롯들은 공유 부모 레이아웃에 props로 전달됩니다. 위 예시에서는 `app/layout.js` 파일 내의 컴포넌트가 이제 `@analytics`와 `@team` 슬롯 props를 받아들이며, 이를 `children` props와 나란히 병렬로 렌더링할 수 있습니다.

```tsx
//app/layout.tsx
export default function Layout({
  children,
  team,
  analytics,
}: {
  children: React.ReactNode
  analytics: React.ReactNode
  team: React.ReactNode
}) {
  return (
    <>
      {children}
      {team}
      {analytics}
    </>
  )
}
```

하지만, 슬롯은 **라우트 세그먼트가 아니며** URL 구조에 영향을 주지 않습니다. 예를 들어, `/@analytics/views`의 경우, URL은 `@analytics` 슬롯이기 때문에 단순히 `/views`로 나타납니다. 슬롯은 일반 [Page](https://nextjs.org/docs/app/api-reference/file-conventions/page) 컴포넌트와 결합되어 라우트 세그먼트와 연결된 최종 페이지를 구성합니다. 이 때문에 같은 라우트 세그먼트 레벨에서 별도의 [정적(static)](https://nextjs.org/docs/app/building-your-application/rendering/server-components#static-rendering-default) 및 [동적(dynamic)](https://nextjs.org/docs/app/building-your-application/rendering/server-components#dynamic-rendering) 슬롯을 가질 수 없습니다. 만약 한 슬롯이 동적이라면, 해당 레벨의 모든 슬롯은 동적이어야 합니다.

> **Good to know**:
> 
> - `children` prop은 폴더에 매핑할 필요가 없는 암묵적 슬롯(implicit slot)입니다. 즉, `app/page.js`는 `app/@children/page.js`와 동일한 의미를 가집니다.

---

## [Active state and navigation](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#active-state-and-navigation)

기본적으로 Next.js는 각 슬롯에 대해 활성 _상태(state)_ (또는 서브페이지)를 추적합니다. 하지만 슬롯 내에서 렌더링되는 내용은 네비게이션의 방식에 따라 달라집니다:

- [**Soft Navigation**](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#5-soft-navigation): 클라이언트 사이드 네비게이션 동안 Next.js는 [부분 렌더링(partial render)](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)을 수행하여 슬롯 내의 서브페이지를 변경합니다. 이때, 현재 URL과 일치하지 않더라도 다른 슬롯의 활성 서브페이지는 그대로 유지됩니다.
- **Hard Navigation**: 전체 페이지 로드(브라우저 새로고침) 후에는 현재 URL과 일치하지 않는 슬롯의 활성 상태를 Next.js가 판단할 수 없습니다. 대신, 일치하지 않는 슬롯에 대해 [`default.js`](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs) 파일을 렌더링하거나, `default.js`가 존재하지 않을 경우 `404` 페이지가 렌더링됩니다.

> **Good to know**:
> 
> - 일치하지 않는 라우트에 대해 `404` 페이지를 렌더링함으로써, 의도하지 않은 페이지에 병렬 라우트가 렌더링되는 것을 방지할 수 있습니다.

---

### [`default.js`](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs)

`default.js` 파일을 정의하여, 초기 로드나 전체 페이지 새로고침 시 일치하지 않는 슬롯에 대한 대체(fallback)를 렌더링할 수 있습니다.

예를 들어 아래의 폴더 구조를 살펴보자. `@team` 슬롯에는 `/settings` 페이지가 존재하지만 `@analytics` 슬롯에는 존재하지 않습니다.

![Parallel Routes unmatched routes](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fparallel-routes-unmatched-routes.png&w=3840&q=75)

`/settings`로 네비게이션하면, `@team` 슬롯은 `/settings` 페이지를 렌더링하면서도 현재 활성 상태인 `@analytics` 슬롯은 그대로 유지됩니다.

새로고침 시, Next.js는 `@analytics`에 대해 `default.js`를 렌더링합니다. 만약 `default.js`가 없다면, `404` 페이지가 대신 렌더링됩니다.

추가로, `children`이 암묵적 슬롯이므로 부모 페이지의 활성 상태를 복원할 수 없을 때 대체로 렌더링할 `default.js` 파일을 생성해야 합니다.

---

### [`useSelectedLayoutSegment(s)`](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#useselectedlayoutsegments)

[`useSelectedLayoutSegment`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segment)와 [`useSelectedLayoutSegments`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segments)는 모두 `parallelRoutesKey` 매개변수를 받아 해당 슬롯 내에서 활성 라우트 세그먼트를 읽을 수 있도록 해줍니다.

```tsx
//app/layout.tsx
'use client'
 
import { useSelectedLayoutSegment } from 'next/navigation'
 
export default function Layout({ auth }: { auth: React.ReactNode }) {
  const loginSegment = useSelectedLayoutSegment('auth')
  // ...
}
```

사용자가 `app/@auth/login` (또는 URL 상에서 `/login`)으로 이동하면, `loginSegment`는 문자열 `"login"`과 같게 됩니다.

---

## [Examples](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#examples)

### [Conditional Routes](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#conditional-routes)

병렬 라우트를 이용하면, 사용자 역할과 같은 특정 조건에 따라 라우트를 조건부로 렌더링할 수 있습니다. 예를 들어, `/admin`과 `/user` 역할에 따라 다른 대시보드 페이지를 렌더링할 수 있습니다:

![Conditional routes diagram](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fconditional-routes-ui.png&w=3840&q=75)

```tsx
//app/dashboard/layout.tsx
import { checkUserRole } from '@/lib/auth'
 
export default function Layout({
  user,
  admin,
}: {
  user: React.ReactNode
  admin: React.ReactNode
}) {
  const role = checkUserRole()
  return role === 'admin' ? admin : user
}
```

---

### [Tab Groups](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#tab-groups)

슬롯 내부에 `layout`을 추가하면, 사용자가 슬롯 내에서 독립적으로 네비게이션할 수 있게 되어 탭(tab) 기능을 구현하는 데 유용합니다.

예를 들어, `@analytics` 슬롯에는 `/page-views`와 `/visitors` 두 개의 서브페이지가 존재합니다.

![Analytics slot with two subpages and a layout](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fparallel-routes-tab-groups.png&w=3840&q=75)

`@analytics` 내에 두 페이지 간에 공통 탭을 공유할 수 있도록 [`layout`](https://nextjs.org/docs/app/building-your-application/routing/layouts-and-templates) 파일을 생성합니다:

```tsx
//app/@analytics/layout.tsx
import Link from 'next/link'
 
export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <nav>
        <Link href="/page-views">Page Views</Link>
        <Link href="/visitors">Visitors</Link>
      </nav>
      <div>{children}</div>
    </>
  )
}
```

---

### [Modals](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#modals)

병렬 라우트는 [Intercepting Routes](https://nextjs.org/docs/app/building-your-application/routing/intercepting-routes)와 함께 사용되어 딥 링크를 지원하는 모달(modal)을 생성할 수 있습니다. 이를 통해 모달을 구현할 때 자주 겪는 문제들을 해결할 수 있습니다. 예를 들어:

- 모달 콘텐츠를 **URL을 통해 공유**할 수 있도록 함.
- 페이지 새로고침 시 모달이 닫히지 않고 **컨텍스트를 유지**할 수 있도록 함.
- 이전 라우트로 이동하는 대신 모달을 **뒤로 가기로 닫을 수** 있도록 함.
- 앞으로 가기로 모달을 **다시 열 수** 있도록 함.

다음 UI 패턴을 살펴보자. 사용자가 레이아웃에서 클라이언트 사이드 네비게이션을 통해 로그인 모달을 열거나 별도의 `/login` 페이지에 접근할 수 있습니다.

![Parallel Routes Diagram](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fparallel-routes-auth-modal.png&w=3840&q=75)

먼저, **메인** 로그인 페이지를 렌더링하는 `/login` 라우트를 생성합니다.

![Parallel Routes Diagram](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fparallel-routes-modal-login-page.png&w=3840&q=75)

```tsx
//app/login/page.tsx
import { Login } from '@/app/ui/login'
 
export default function Page() {
  return <Login />
}
```

그 후, `@auth` 슬롯 내부에 [`default.js`](https://nextjs.org/docs/app/api-reference/file-conventions/default) 파일을 추가하여, 모달이 활성화되지 않았을 때 렌더링되지 않도록 합니다.

```tsx
//app/@auth/default.tsx
export default function Default() {
  return null
}
```

그리고 `@auth` 슬롯 내부에서 `/login` 라우트를 인터셉트(intercept)하기 위해, `/(.)login` 폴더를 업데이트합니다. 이 파일에서 `<Modal>` 컴포넌트와 그 자식 요소들을 import 합니다:

```tsx
//app/@auth/(.)login/page.tsx
import { Modal } from '@/app/ui/modal'
import { Login } from '@/app/ui/login'
 
export default function Page() {
  return (
    <Modal>
      <Login />
    </Modal>
  )
}
```

> **Good to know:**
> 
> - 라우트를 인터셉트하는 데 사용되는 규칙(예: `(.)` 등)은 파일 시스템 구조에 따라 달라집니다. 자세한 내용은 [Intercepting Routes convention](https://nextjs.org/docs/app/building-your-application/routing/intercepting-routes#convention)을 참고하세요.
> - `<Modal>` 기능과 모달 콘텐츠(`<Login>`)를 분리함으로써, 모달 내부의 내용(예: [forms](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations#forms))을 Server Component로 유지할 수 있습니다. 자세한 내용은 [Interleaving Client and Server Components](https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns#supported-pattern-passing-server-components-to-client-components-as-props)를 참고하세요.

#### [Opening the modal](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#opening-the-modal)

이제 Next.js의 라우터를 활용하여 모달을 열고 닫을 수 있습니다. 이렇게 하면 모달이 열릴 때 URL이 올바르게 업데이트되며, 뒤로 가기 및 앞으로 가기 시에도 올바른 동작을 합니다.

모달을 열기 위해, 부모 레이아웃에 `@auth` 슬롯을 props로 전달하고 `children` prop과 함께 렌더링합니다.

```tsx
//app/layout.tsx
import Link from 'next/link'
 
export default function Layout({
  auth,
  children,
}: {
  auth: React.ReactNode
  children: React.ReactNode
}) {
  return (
    <>
      <nav>
        <Link href="/login">Open modal</Link>
      </nav>
      <div>{auth}</div>
      <div>{children}</div>
    </>
  )
}
```

사용자가 `<Link>`를 클릭하면, 모달이 열리게 되고 `/login` 페이지로 이동하지 않습니다. 다만, 새로고침이나 초기 로드시 `/login`으로 이동하면 메인 로그인 페이지가 나타납니다.

#### [Closing the modal](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#closing-the-modal)

모달을 닫으려면 `router.back()`을 호출하거나 `<Link>` 컴포넌트를 사용하면 됩니다.

```tsx
//app/ui/modal.tsx
'use client'
 
import { useRouter } from 'next/navigation'
 
export function Modal({ children }: { children: React.ReactNode }) {
  const router = useRouter()
 
  return (
    <>
      <button
        onClick={() => {
          router.back()
        }}
      >
        Close modal
      </button>
      <div>{children}</div>
    </>
  )
}
```

또한, 모달 슬롯(`@auth`)이 더 이상 렌더링되지 않아야 하는 페이지로 `<Link>`를 사용해 이동할 경우, 해당 병렬 라우트가 `null`을 반환하는 컴포넌트와 매칭되도록 해야 합니다. 예를 들어, 루트 페이지로 이동할 때는 `@auth/page.tsx` 컴포넌트를 생성합니다:

```tsx
//app/ui/modal.tsx
import Link from 'next/link'
 
export function Modal({ children }: { children: React.ReactNode }) {
  return (
    <>
      <Link href="/">Close modal</Link>
      <div>{children}</div>
    </>
  )
}
```

```tsx
//app/@auth/page.tsx
export default function Page() {
  return null
}
```

또는 `/foo`, `/foo/bar` 등 다른 페이지로 이동할 경우, 캐치 올(catch-all) 슬롯을 사용할 수 있습니다:

```tsx
//app/@auth/[...catchAll]/page.tsx
export default function CatchAll() {
  return null
}
```

> **Good to know:**
> 
> - 클라이언트 사이드 네비게이션 시, 더 이상 슬롯과 일치하지 않는 라우트의 경우 기존에 렌더링되던 슬롯이 그대로 남아있기 때문에, 모달을 닫기 위해서는 해당 슬롯과 매칭되는 컴포넌트가 `null`을 반환하도록 해야 합니다.
> - 다른 예시로는, 갤러리에서 사진 모달을 열면서 동시에 `/photo/[id]` 페이지를 가지거나, 사이드 모달에서 쇼핑 카트를 여는 경우 등이 있을 수 있습니다.
> - [View an example](https://github.com/vercel-labs/nextgram)에서 Intercepted 및 Parallel Routes를 활용한 모달 예제를 확인할 수 있습니다.

---

### [Loading and Error UI](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#loading-and-error-ui)

병렬 라우트는 독립적으로 스트리밍(streaming)될 수 있으므로, 각 라우트마다 별도의 에러 및 로딩 상태를 정의할 수 있습니다.

![Parallel routes enable custom error and loading states](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fparallel-routes-cinematic-universe.png&w=3840&q=75)

자세한 내용은 [Loading UI](https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming)와 [Error Handling](https://nextjs.org/docs/app/building-your-application/routing/error-handling) 문서를 참고하길 바란다.

---

이상으로 Next.js의 Parallel Routes에 관한 공식문서 내용을 번역해 보았어. 혹시 잘 이해되지 않거나 더 궁금한 점이 있다면 솔직하게 “모르겠다”라고 답할 수 있으니, 추가 질문이 있으면 언제든 물어봐줘.

너의 Next.js 학습에 큰 도움이 되길 바란다.

— 최고 전문가 지피 드림.


#nextJS #공식문서 