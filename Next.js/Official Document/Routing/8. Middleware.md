> 이 글은 chat gpt o3 mini 모델로 번역한 Next.js 공식문서 입니다. 오직 개인의 학습을 위함이 목적입니다.

다음은 Next.js 공식문서의 미들웨어(Middleware) 관련 내용을 전자책 형식으로, 초보 개발자도 쉽게 이해할 수 있도록 자연스러운 한국어로 번역한 내용입니다. 원본의 내용은 한 문장, 한 문장 빠짐없이 번역되었으며, 코드 블록과 링크(이미지 링크 포함)도 그대로 표시하였습니다.

---

# 미들웨어 (Middleware)

미들웨어는 요청(request)이 완료되기 전에 코드를 실행할 수 있도록 해줍니다. 그리고 들어오는 요청을 기반으로, 응답(response)을 재작성(rewrite), 리디렉션(redirect), 요청 또는 응답 헤더를 수정하거나 직접 응답하는 방식으로 변경할 수 있습니다.

미들웨어는 캐시된 콘텐츠와 라우트(route)가 매칭되기 전에 실행됩니다. 자세한 내용은 [Matching Paths](https://nextjs.org/docs/app/building-your-application/routing/middleware#matching-paths)를 참고하세요.

---

## 사용 사례 (Use Cases)

애플리케이션에 미들웨어를 통합하면 성능, 보안, 사용자 경험에서 큰 개선을 이룰 수 있습니다. 미들웨어가 특히 효과적인 몇 가지 일반적인 시나리오는 다음과 같습니다:

- **인증 및 권한 부여**  
    특정 페이지나 API 경로에 접근을 허용하기 전에 사용자의 신원을 확인하고 세션 쿠키를 점검합니다.
    
- **서버 사이드 리디렉션**  
    특정 조건(예: 로케일, 사용자 역할)에 따라 서버 수준에서 사용자를 다른 URL로 리디렉션합니다.
    
- **경로 재작성**  
    요청 속성을 기반으로 경로를 API 경로나 페이지로 동적으로 재작성하여 A/B 테스트, 기능 롤아웃, 또는 이전(legacy) 경로를 지원합니다.
    
- **봇 감지**  
    봇 트래픽을 감지하고 차단함으로써 리소스를 보호합니다.
    
- **로깅 및 분석**  
    페이지나 API에서 처리되기 전에 요청 데이터를 수집 및 분석하여 인사이트를 얻습니다.
    
- **기능 플래깅 (Feature Flagging)**  
    기능 롤아웃이나 테스트를 원활하게 진행하기 위해 기능을 동적으로 활성화하거나 비활성화합니다.
    

반면에 미들웨어가 최적의 접근 방식이 아닐 수 있는 상황도 있습니다:

- **복잡한 데이터 가져오기 및 조작**  
    미들웨어는 직접적인 데이터 가져오기나 조작을 위해 설계되지 않았으므로, 이러한 작업은 라우트 핸들러나 서버 사이드 유틸리티에서 처리해야 합니다.
    
- **무거운 계산 작업**  
    미들웨어는 가볍고 빠르게 응답해야 하므로, 무거운 계산 작업이나 장시간 실행되는 프로세스는 전용 라우트 핸들러에서 수행해야 합니다.
    
- **광범위한 세션 관리**  
    미들웨어는 기본적인 세션 작업은 처리할 수 있지만, 복잡하거나 광범위한 세션 관리는 전용 인증 서비스나 라우트 핸들러에서 관리하는 것이 좋습니다.
    
- **직접적인 데이터베이스 작업**  
    미들웨어 내에서 직접 데이터베이스 작업을 수행하는 것은 권장되지 않습니다. 데이터베이스와의 상호작용은 라우트 핸들러나 서버 사이드 유틸리티에서 처리해야 합니다.
    

---

## 규칙 (Convention)

프로젝트 루트에 있는 `middleware.ts` (또는 `.js`) 파일을 사용하여 미들웨어를 정의합니다. 예를 들어, `pages` 또는 `app`과 같은 디렉토리와 같은 수준에 두거나, 필요에 따라 `src` 폴더 내부에 위치시킬 수 있습니다.

> **참고**: 프로젝트 당 하나의 `middleware.ts` 파일만 지원되지만, 미들웨어 로직은 모듈화하여 관리할 수 있습니다. 미들웨어 기능들을 별도의 `.ts` 또는 `.js` 파일로 분리한 후 메인 `middleware.ts` 파일에 import 함으로써, 경로별 미들웨어를 깔끔하게 관리하고 중앙집중식 제어가 가능합니다. 단일 미들웨어 파일을 사용함으로써 설정이 단순해지고, 잠재적인 충돌을 방지하며, 여러 미들웨어 계층을 피해 성능을 최적화할 수 있습니다.

---

## 예제 (Example)

```tsx
//middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
 
// 내부에서 await을 사용할 경우 이 함수를 async로 선언할 수 있습니다.
export function middleware(request: NextRequest) {
  return NextResponse.redirect(new URL('/home', request.url))
}
 
// 자세한 내용은 아래의 "Matching Paths" 섹션을 참고하세요.
export const config = {
  matcher: '/about/:path*',
}
```

---

## 경로 매칭 (Matching Paths)

미들웨어는 **프로젝트 내의 모든 라우트**에 대해 호출됩니다. 이로 인해 특정 라우트만 대상으로 하거나 제외할 수 있도록 matchers를 사용하는 것이 매우 중요합니다. 미들웨어 실행 순서는 다음과 같습니다:

1. `next.config.js`의 `headers`
2. `next.config.js`의 `redirects`
3. 미들웨어 (rewrites, redirects 등)
4. `next.config.js`의 `beforeFiles` (rewrites)
5. 파일 시스템 라우트 (예: `public/`, `_next/static/`, `pages/`, `app/` 등)
6. `next.config.js`의 `afterFiles` (rewrites)
7. 동적 라우트 (예: `/blog/[slug]`)
8. `next.config.js`의 `fallback` (rewrites)

미들웨어가 실행될 경로를 정의하는 방법은 두 가지가 있습니다:

1. [커스텀 매처 설정 (Custom matcher config)](https://nextjs.org/docs/app/building-your-application/routing/middleware#matcher)
2. [조건문 (Conditional statements)](https://nextjs.org/docs/app/building-your-application/routing/middleware#conditional-statements)

---

### 매처 (Matcher)

`matcher`를 사용하면 특정 경로에서만 미들웨어가 실행되도록 필터링할 수 있습니다.

```tsx
//middleware.js
export const config = {
  matcher: '/about/:path*',
}
```

단일 경로뿐 아니라 배열 문법을 사용하여 여러 경로를 매칭할 수도 있습니다:

```tsx
//middleware.js
export const config = {
  matcher: ['/about/:path*', '/dashboard/:path*'],
}
```

`matcher` 설정은 정규식을 완전하게 지원하므로, 부정형 전방 탐색(negative lookaheads)이나 문자 매칭 등을 사용할 수 있습니다. 특정 경로를 제외하고 모든 경로를 매칭하는 부정형 전방 탐색의 예는 다음과 같습니다:

```js
//middleware.js
export const config = {
  matcher: [
    /*
     * 다음으로 시작하지 않는 모든 요청 경로를 매칭합니다:
     * - api (API 라우트)
     * - _next/static (정적 파일)
     * - _next/image (이미지 최적화 파일)
     * - favicon.ico, sitemap.xml, robots.txt (메타데이터 파일)
     */
    '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',
  ],
}
```

또한 `missing` 또는 `has` 배열(혹은 둘의 조합)을 사용하여 특정 요청에 대해 미들웨어를 우회(bypass)할 수도 있습니다:

```js
//middleware.js
export const config = {
  matcher: [
    /*
     * 다음으로 시작하지 않는 모든 요청 경로를 매칭합니다:
     * - api (API 라우트)
     * - _next/static (정적 파일)
     * - _next/image (이미지 최적화 파일)
     * - favicon.ico, sitemap.xml, robots.txt (메타데이터 파일)
     */
    {
      source:
        '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',
      missing: [
        { type: 'header', key: 'next-router-prefetch' },
        { type: 'header', key: 'purpose', value: 'prefetch' },
      ],
    },
 
    {
      source:
        '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',
      has: [
        { type: 'header', key: 'next-router-prefetch' },
        { type: 'header', key: 'purpose', value: 'prefetch' },
      ],
    },
 
    {
      source:
        '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',
      has: [{ type: 'header', key: 'x-present' }],
      missing: [{ type: 'header', key: 'x-missing', value: 'prefetch' }],
    },
  ],
}
```

> **알아두면 좋은 점**: `matcher` 값은 빌드 타임에 정적으로 분석될 수 있도록 상수여야 합니다. 변수와 같은 동적 값은 무시됩니다.

설정된 매처 규칙은 다음과 같습니다:

1. 반드시 `/`로 시작해야 합니다.
2. 이름이 지정된 파라미터(named parameters)를 포함할 수 있습니다. 예를 들어, `/about/:path`는 `/about/a`와 `/about/b`에 매칭되지만 `/about/a/c`에는 매칭되지 않습니다.
3. 이름이 지정된 파라미터에는 수정자(modifiers)를 붙일 수 있습니다 (예: `*`, `?`, `+`). 예를 들어, `/about/:path*`는 `/about/a/b/c`에 매칭되는데, 이는 `*`가 _0개 이상의_ 값을 의미하기 때문입니다. 여기서 `?`는 _0개 또는 1개_, `+`는 _1개 이상의_ 값을 의미합니다.
4. 소괄호로 감싼 정규식을 사용할 수 있습니다. 예를 들어, `/about/(.*)`는 `/about/:path*`와 동일한 효과를 가집니다.

자세한 내용은 [path-to-regexp](https://github.com/pillarjs/path-to-regexp#path-to-regexp-1) 문서를 참고하세요.

> **알아두면 좋은 점**: 하위 호환성을 위해 Next.js는 항상 `/public`을 `/public/index`로 간주합니다. 따라서 `/public/:path`에 대한 매처는 올바르게 매칭됩니다.

---

### 조건문 (Conditional Statements)

조건문을 사용하여 특정 경로에서 미들웨어가 실행되도록 할 수 있습니다.

```tsx
//middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
 
export function middleware(request: NextRequest) {
  if (request.nextUrl.pathname.startsWith('/about')) {
    return NextResponse.rewrite(new URL('/about-2', request.url))
  }
 
  if (request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.rewrite(new URL('/dashboard/user', request.url))
  }
}
```

---

## NextResponse

`NextResponse` API를 사용하면 다음과 같은 작업들을 수행할 수 있습니다:

- 들어오는 요청을 다른 URL로 **리디렉션(redirect)** 할 수 있습니다.
- 지정된 URL을 표시하여 응답을 **재작성(rewrite)** 할 수 있습니다.
- API 라우트, `getServerSideProps`, 또는 `rewrite` 대상에 대해 요청 헤더를 설정할 수 있습니다.
- 응답 쿠키(response cookies)를 설정할 수 있습니다.
- 응답 헤더(response headers)를 설정할 수 있습니다.

미들웨어에서 응답을 생성하는 방법은 두 가지입니다:

1. 응답을 생성하는 라우트(예: [Page](https://nextjs.org/docs/app/api-reference/file-conventions/page) 또는 [Route Handler](https://nextjs.org/docs/app/building-your-application/routing/route-handlers))로 **rewrite**합니다.
2. `NextResponse`를 직접 반환합니다. 자세한 내용은 [Producing a Response](https://nextjs.org/docs/app/building-your-application/routing/middleware#producing-a-response)를 참고하세요.

---

## 쿠키 사용 (Using Cookies)

쿠키는 일반적인 헤더입니다. 요청에서는 `Cookie` 헤더에 저장되며, 응답에서는 `Set-Cookie` 헤더에 포함됩니다. Next.js는 `NextRequest`와 `NextResponse`의 `cookies` 확장을 통해 쿠키에 쉽게 접근하고 조작할 수 있도록 도와줍니다.

1. **들어오는 요청의 경우**  
    `cookies`에는 `get`, `getAll`, `set`, `delete` 메소드가 제공됩니다. 또한, `has` 메소드를 사용하여 쿠키의 존재 여부를 확인하거나, `clear`를 사용하여 모든 쿠키를 제거할 수 있습니다.
    
2. **나가는 응답의 경우**  
    `cookies`에는 `get`, `getAll`, `set`, `delete` 메소드가 제공됩니다.
    

```tsx
//middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
 
export function middleware(request: NextRequest) {
  // 들어오는 요청에 "Cookie: nextjs=fast" 헤더가 있다고 가정합니다.
  // `RequestCookies` API를 사용하여 요청의 쿠키를 가져옵니다.
  let cookie = request.cookies.get('nextjs')
  console.log(cookie) // => { name: 'nextjs', value: 'fast', Path: '/' }
  const allCookies = request.cookies.getAll()
  console.log(allCookies) // => [{ name: 'nextjs', value: 'fast' }]
 
  request.cookies.has('nextjs') // => true
  request.cookies.delete('nextjs')
  request.cookies.has('nextjs') // => false
 
  // `ResponseCookies` API를 사용하여 응답에 쿠키를 설정합니다.
  const response = NextResponse.next()
  response.cookies.set('vercel', 'fast')
  response.cookies.set({
    name: 'vercel',
    value: 'fast',
    path: '/',
  })
  cookie = response.cookies.get('vercel')
  console.log(cookie) // => { name: 'vercel', value: 'fast', Path: '/' }
  // 나가는 응답은 `Set-Cookie: vercel=fast;path=/` 헤더를 포함하게 됩니다.
 
  return response
}
```

---

## 헤더 설정 (Setting Headers)

`NextResponse` API를 사용하면 요청 및 응답 헤더를 설정할 수 있습니다. (요청 헤더 설정은 Next.js v13.0.0부터 가능합니다.)

```tsx
//middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
 
export function middleware(request: NextRequest) {
  // 요청 헤더를 복제한 후 새로운 헤더 `x-hello-from-middleware1`을 설정합니다.
  const requestHeaders = new Headers(request.headers)
  requestHeaders.set('x-hello-from-middleware1', 'hello')
 
  // NextResponse.next에서도 요청 헤더를 설정할 수 있습니다.
  const response = NextResponse.next({
    request: {
      // 새로운 요청 헤더
      headers: requestHeaders,
    },
  })
 
  // 응답 헤더에 새로운 헤더 `x-hello-from-middleware2`를 설정합니다.
  response.headers.set('x-hello-from-middleware2', 'hello')
  return response
}
```

> **알아두면 좋은 점**: 큰 헤더를 설정하는 것은 피해야 합니다. 이는 백엔드 웹 서버 설정에 따라 [431 Request Header Fields Too Large](https://developer.mozilla.org/docs/Web/HTTP/Status/431) 오류를 발생시킬 수 있습니다.

---

### CORS

미들웨어에서 CORS 헤더를 설정하여, [간단한 요청](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests)과 [사전 검사된 요청](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#preflighted_requests)을 포함한 교차 출처 요청을 허용할 수 있습니다.

```tsx
//middleware.ts
import { NextRequest, NextResponse } from 'next/server'
 
const allowedOrigins = ['https://acme.com', 'https://my-app.org']
 
const corsOptions = {
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
}
 
export function middleware(request: NextRequest) {
  // 요청의 origin 헤더를 확인합니다.
  const origin = request.headers.get('origin') ?? ''
  const isAllowedOrigin = allowedOrigins.includes(origin)
 
  // 사전 검사(preflight) 요청 처리
  const isPreflight = request.method === 'OPTIONS'
 
  if (isPreflight) {
    const preflightHeaders = {
      ...(isAllowedOrigin && { 'Access-Control-Allow-Origin': origin }),
      ...corsOptions,
    }
    return NextResponse.json({}, { headers: preflightHeaders })
  }
 
  // 간단한 요청 처리
  const response = NextResponse.next()
 
  if (isAllowedOrigin) {
    response.headers.set('Access-Control-Allow-Origin', origin)
  }
 
  Object.entries(corsOptions).forEach(([key, value]) => {
    response.headers.set(key, value)
  })
 
  return response
}
 
export const config = {
  matcher: '/api/:path*',
}
```

> **알아두면 좋은 점**: [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers#cors)에서 개별 경로에 대해 CORS 헤더를 설정할 수 있습니다.

---

## 응답 생성 (Producing a Response)

미들웨어에서는 직접 `Response` 또는 `NextResponse` 인스턴스를 반환하여 응답할 수 있습니다. (이는 [Next.js v13.1.0](https://nextjs.org/blog/next-13-1#nextjs-advanced-middleware)부터 사용 가능합니다.)

```tsx
//middleware.ts
import type { NextRequest } from 'next/server'
import { isAuthenticated } from '@lib/auth'
 
// 미들웨어를 `/api/`로 시작하는 경로에 한정합니다.
export const config = {
  matcher: '/api/:function*',
}
 
export function middleware(request: NextRequest) {
  // 인증 함수를 호출하여 요청을 점검합니다.
  if (!isAuthenticated(request)) {
    // 인증 실패 시, JSON 형식의 오류 메시지로 응답합니다.
    return Response.json(
      { success: false, message: 'authentication failed' },
      { status: 401 }
    )
  }
}
```

---

### `waitUntil` 및 `NextFetchEvent`

`NextFetchEvent` 객체는 네이티브 [`FetchEvent`](https://developer.mozilla.org/docs/Web/API/FetchEvent) 객체를 확장하며, [`waitUntil()`](https://developer.mozilla.org/docs/Web/API/ExtendableEvent/waitUntil) 메소드를 포함합니다.

`waitUntil()` 메소드는 promise를 인자로 받아, 해당 promise가 완료될 때까지 미들웨어의 수명을 연장합니다. 이는 백그라운드 작업을 수행할 때 유용합니다.

```tsx
//middleware.ts
import { NextResponse } from 'next/server'
import type { NextFetchEvent, NextRequest } from 'next/server'
 
export function middleware(req: NextRequest, event: NextFetchEvent) {
  event.waitUntil(
    fetch('https://my-analytics-platform.com', {
      method: 'POST',
      body: JSON.stringify({ pathname: req.nextUrl.pathname }),
    })
  )
 
  return NextResponse.next()
}
```

---

## 고급 미들웨어 플래그 (Advanced Middleware Flags)

Next.js v13.1부터 미들웨어를 위한 두 개의 추가 플래그인 `skipMiddlewareUrlNormalize`와 `skipTrailingSlashRedirect`가 도입되어 고급 사용 사례를 처리할 수 있게 되었습니다.

### skipTrailingSlashRedirect

`skipTrailingSlashRedirect`는 끝에 슬래시를 추가하거나 제거하는 Next.js의 기본 리디렉션을 비활성화합니다. 이를 통해 미들웨어 내에서 특정 경로에 대해 끝 슬래시를 유지하거나 제거하는 커스텀 처리를 할 수 있어, 점진적인 마이그레이션을 쉽게 진행할 수 있습니다.

```tsx
//next.config.js
module.exports = {
  skipTrailingSlashRedirect: true,
}
```

```tsx
//middleware.js
const legacyPrefixes = ['/docs', '/blog']
 
export default async function middleware(req) {
  const { pathname } = req.nextUrl
 
  if (legacyPrefixes.some((prefix) => pathname.startsWith(prefix))) {
    return NextResponse.next()
  }
 
  // 끝 슬래시 처리를 적용합니다.
  if (
    !pathname.endsWith('/') &&
    !pathname.match(/((?!\.well-known(?:\/.*)?)(?:[^/]+\/)*[^/]+\.\w+)/)
  ) {
    return NextResponse.redirect(
      new URL(`${req.nextUrl.pathname}/`, req.nextUrl)
    )
  }
}
```

### skipMiddlewareUrlNormalize

`skipMiddlewareUrlNormalize`를 사용하면 Next.js의 URL 정규화를 비활성화하여, 직접 방문과 클라이언트 전환 간의 URL 처리를 동일하게 만들 수 있습니다. 일부 고급 사례에서는 이 옵션을 통해 원본 URL을 사용한 완전한 제어가 가능합니다.

```tsx
//next.config.js
module.exports = {
  skipMiddlewareUrlNormalize: true,
}
```

```tsx
//middleware.js
export default async function middleware(req) {
  const { pathname } = req.nextUrl
 
  // 예시: GET /_next/data/build-id/hello.json
 
  console.log(pathname)
  // 플래그를 사용하면, 현재 pathname은 /_next/data/build-id/hello.json 입니다.
  // 플래그를 사용하지 않으면, 이는 /hello로 정규화됩니다.
}
```

---

## 단위 테스트 (실험적 기능) (Unit Testing (experimental))

Next.js 15.1부터는 `next/experimental/testing/server` 패키지에 미들웨어 파일의 단위 테스트를 도와주는 유틸리티들이 포함되어 있습니다. 미들웨어 단위 테스트를 통해, 코드가 프로덕션에 배포되기 전에 미들웨어가 원하는 경로에서만 실행되며 커스텀 라우팅 로직이 의도대로 작동하는지 확인할 수 있습니다.

`unstable_doesMiddlewareMatch` 함수를 사용하여 제공된 URL, 헤더, 쿠키에 대해 미들웨어가 실행될지를 검증할 수 있습니다.

```tsx
import { unstable_doesMiddlewareMatch } from 'next/experimental/testing/server'
 
expect(
  unstable_doesMiddlewareMatch({
    config,
    nextConfig,
    url: '/test',
  })
).toEqual(false)
```

전체 미들웨어 함수 또한 테스트할 수 있습니다.

```tsx
import { isRewrite, getRewrittenUrl } from 'next/experimental/testing/server'
 
const request = new NextRequest('https://nextjs.org/docs')
const response = await middleware(request)
expect(isRewrite(response)).toEqual(true)
expect(getRewrittenUrl(response)).toEqual('https://other-domain.com/docs')
// 응답이 리디렉션일 경우 getRedirectUrl도 사용할 수 있습니다.
```

---

## 런타임 (Runtime)

현재 미들웨어는 [Edge 런타임](https://nextjs.org/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes)과 호환되는 API만 지원합니다. Node.js 전용 API는 [지원되지 않습니다](https://nextjs.org/docs/app/api-reference/edge#unsupported-apis).

---

이상으로 Next.js 미들웨어에 관한 공식문서 내용을 번역하여 자세히 설명드렸습니다. 혹시 추가적인 부분이나 잘 이해되지 않는 내용이 있다면 언제든지 질문해 주세요.

_Next.js 분야의 최고 전문가 지피가 전자책처럼 정리해 드렸습니다._




#nextJS #공식문서 