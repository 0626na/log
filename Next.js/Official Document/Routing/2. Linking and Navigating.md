> 이 글은 chat gpt o3 mini 모델로 번역한 Next.js 공식문서 입니다. 오직 개인의 학습을 위함이 목적입니다.

아래는 Next.js 공식문서의 해당 부분을 전자책 형식으로, Next.js를 처음 배우는 개발자도 쉽게 이해할 수 있도록 자연스러운 한국어로 번역한 내용입니다.

---

# 1장. 링크 및 네비게이션 (Linking and Navigating)

Next.js에서는 라우트 간의 이동(네비게이션)을 위한 네 가지 방법을 제공합니다.

- **[`<Link>` 컴포넌트 사용하기](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#link-component)**
- **[`useRouter` 훅 사용하기](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#userouter-hook)** ([클라이언트 컴포넌트](https://nextjs.org/docs/app/building-your-application/rendering/client-components))
- **[`redirect` 함수 사용하기](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#redirect-function)** ([서버 컴포넌트](https://nextjs.org/docs/app/building-your-application/rendering/server-components))
- **네이티브 [History API](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#using-the-native-history-api) 사용하기**

이 장에서는 위의 옵션들을 어떻게 사용하는지 차근차근 설명하며, 네비게이션이 어떻게 동작하는지 더 깊게 살펴봅니다.

---

# 2장. `<Link>` 컴포넌트

`<Link>` 컴포넌트는 HTML의 `<a>` 태그를 확장하여, 라우트 간 클라이언트 사이드 네비게이션과 [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)을 제공하는 내장 컴포넌트입니다. Next.js에서는 라우트 간 이동 시 기본적이고 추천되는 방법으로 사용됩니다.

사용 방법은 `next/link`에서 `<Link>`를 임포트한 후, `href` 속성을 전달하는 것입니다.

```tsx
//app/page.tsx
import Link from 'next/link'
 
export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

추가로 `<Link>`에 전달할 수 있는 선택적 속성들이 있으며, 이에 대한 자세한 내용은 [API 레퍼런스](https://nextjs.org/docs/app/api-reference/components/link)를 참고하세요.

---

# 3장. `useRouter()` 훅

`useRouter` 훅을 사용하면 클라이언트 컴포넌트 내에서 프로그래밍 방식으로 라우트를 변경할 수 있습니다. 예를 들어 버튼 클릭 시 특정 라우트로 이동할 때 유용합니다.

```tsx
//app/page.tsx
'use client'
 
import { useRouter } from 'next/navigation'
 
export default function Page() {
  const router = useRouter()
 
  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

`useRouter`에서 제공하는 메소드 전체 목록은 [API 레퍼런스](https://nextjs.org/docs/app/api-reference/functions/use-router)를 참고하세요.

**추천:** 특별한 이유가 없다면 라우트 간 이동은 `<Link>` 컴포넌트를 사용하는 것이 좋습니다.

---

# 4장. `redirect` 함수

서버 컴포넌트에서는 `redirect` 함수를 사용하여 라우트 간 이동을 처리합니다.

```tsx
//app/team/[id]/page.tsx
import { redirect } from 'next/navigation'
 
async function fetchTeam(id: string) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}
 
export default async function Profile({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const id = (await params).id
  if (!id) {
    redirect('/login')
  }
 
  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }
 
  // ...
}
```

> **알아두면 좋은 점:**
> 
> - 기본적으로 `redirect`는 307 (임시 리다이렉트) 상태 코드를 반환합니다. 서버 액션 내에서 사용될 때는 POST 요청 후 성공 페이지로 리다이렉션하는 데 흔히 사용되는 303 (See Other) 상태 코드를 반환합니다.
> - `redirect` 함수는 내부적으로 에러를 발생시키므로 `try/catch` 블록 외부에서 호출해야 합니다.
> - 렌더링 과정 중 클라이언트 컴포넌트에서 호출할 수 있으나, 이벤트 핸들러 내에서는 사용할 수 없습니다. 그런 경우에는 대신 [`useRouter` 훅](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#userouter-hook)을 사용하세요.
> - `redirect`는 절대 URL도 지원하므로 외부 링크로 리다이렉션할 때도 사용할 수 있습니다.
> - 렌더링 전에 리다이렉션을 하고 싶다면, [`next.config.js`](https://nextjs.org/docs/app/building-your-application/routing/redirecting#redirects-in-nextconfigjs) 또는 [미들웨어](https://nextjs.org/docs/app/building-your-application/routing/redirecting#nextresponseredirect-in-middleware)를 사용하세요.

자세한 내용은 [`redirect` API 레퍼런스](https://nextjs.org/docs/app/api-reference/functions/redirect)를 참고하시기 바랍니다.

---

# 5장. 네이티브 History API 사용하기

Next.js는 브라우저의 페이지 새로고침 없이 History API의 네이티브 메소드인 [`window.history.pushState`](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#windowhistorypushstate)와 [`window.history.replaceState`](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#windowhistoryreplacestate)를 사용할 수 있도록 지원합니다.

이 메소드들은 Next.js 라우터와 통합되어, [`usePathname`](https://nextjs.org/docs/app/api-reference/functions/use-pathname) 및 [`useSearchParams`](https://nextjs.org/docs/app/api-reference/functions/use-search-params)와 연동할 수 있습니다.

---

## 5.1. [`window.history.pushState`](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#windowhistorypushstate)

`pushState`를 사용하면 브라우저의 히스토리 스택에 새로운 항목을 추가할 수 있습니다. 이 경우 사용자는 이전 상태로 돌아갈 수 있게 됩니다. 예를 들어, 상품 목록을 정렬할 때 다음과 같이 사용할 수 있습니다.

```tsx
'use client'
 
import { useSearchParams } from 'next/navigation'
 
export default function SortProducts() {
  const searchParams = useSearchParams()
 
  function updateSorting(sortOrder: string) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }
 
  return (
    <>
      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>
      <button onClick={() => updateSorting('desc')}>Sort Descending</button>
    </>
  )
}
```

---

## 5.2. [`window.history.replaceState`](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#windowhistoryreplacestate)

`replaceState`를 사용하면 브라우저의 히스토리 스택에서 현재 항목을 교체할 수 있습니다. 이 경우 사용자가 이전 상태로 돌아갈 수 없습니다. 예를 들어, 애플리케이션의 로케일(언어)을 전환할 때 다음과 같이 사용할 수 있습니다.

```tsx
'use client'
 
import { usePathname } from 'next/navigation'
 
export function LocaleSwitcher() {
  const pathname = usePathname()
 
  function switchLocale(locale: string) {
    // 예: '/en/about' 또는 '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }
 
  return (
    <>
      <button onClick={() => switchLocale('en')}>English</button>
      <button onClick={() => switchLocale('fr')}>French</button>
    </>
  )
}
```

---

# 6장. 라우팅과 네비게이션의 동작 방식 (How Routing and Navigation Works)

Next.js의 App Router는 라우팅과 네비게이션을 위해 하이브리드 접근 방식을 사용합니다.  
서버 측에서는 애플리케이션 코드를 라우트 세그먼트 별로 자동 [코드 스플리팅](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#1-code-splitting)하며, 클라이언트 측에서는 Next.js가 라우트 세그먼트를 [prefetch](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)하고 [캐싱](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#3-caching)합니다.  
즉, 사용자가 새로운 라우트로 이동할 때 브라우저는 페이지 전체를 새로 고치지 않고, 변경된 라우트 세그먼트만 다시 렌더링하여 네비게이션 경험과 성능을 향상시킵니다.

---

## 6.1. 코드 스플리팅 (Code Splitting)

코드 스플리팅은 애플리케이션 코드를 작은 번들로 나누어 브라우저가 필요할 때마다 다운로드하고 실행할 수 있도록 하는 기법입니다.  
이 방식은 전송되는 데이터 양과 요청 시 실행 시간이 줄어들어 성능 향상에 도움을 줍니다.

[서버 컴포넌트](https://nextjs.org/docs/app/building-your-application/rendering/server-components)를 사용하면, 라우트 세그먼트 별로 자동으로 코드 스플리팅이 이루어집니다. 즉, 현재 라우트에 필요한 코드만 로드됩니다.

---

## 6.2. 프리페칭 (Prefetching)

프리페칭은 사용자가 해당 라우트를 방문하기 전에 백그라운드에서 미리 로드하는 방법입니다.

Next.js에서는 두 가지 방식으로 라우트를 프리페칭합니다.

- **`<Link>` 컴포넌트:** 라우트가 사용자의 뷰포트에 보이게 되면 자동으로 프리페칭됩니다. 페이지가 처음 로드되거나 스크롤로 화면에 들어올 때 프리페칭이 이루어집니다.
- **`router.prefetch()` 사용:** `useRouter` 훅을 이용하여 프로그래밍 방식으로 라우트를 프리페칭할 수도 있습니다.

`<Link>`의 기본 프리페칭 동작(즉, `prefetch` 속성을 명시하지 않거나 `null`로 설정한 경우)은 [`loading.js`](https://nextjs.org/docs/app/api-reference/file-conventions/loading)의 사용 여부에 따라 달라집니다.  
공유 레이아웃, 즉 첫 번째 `loading.js` 파일까지 렌더링된 "트리"는 프리페칭되어 30초 동안 캐시됩니다.  
이 방식은 동적 라우트 전체 데이터를 가져오는 비용을 줄여주며, 사용자에게 [즉각적인 로딩 상태](https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)를 제공할 수 있게 합니다.

프리페칭을 비활성화하려면 `prefetch` 속성을 `false`로 설정하면 됩니다.  
또는, 로딩 경계 바깥의 전체 페이지 데이터를 프리페칭하고 싶다면 `prefetch` 속성을 `true`로 설정하세요.

자세한 정보는 [`<Link>` API 레퍼런스](https://nextjs.org/docs/app/api-reference/components/link)를 참조하세요.

> **알아두면 좋은 점:**
> 
> - 프리페칭은 개발 환경에서는 활성화되지 않고, 프로덕션 환경에서만 동작합니다.

---

## 6.3. 캐싱 (Caching)

Next.js는 **클라이언트 측 인메모리 캐시**인 [라우터 캐시(Router Cache)](https://nextjs.org/docs/app/building-your-application/caching#client-side-router-cache)를 제공합니다.  
사용자가 애플리케이션 내에서 네비게이션할 때, 프리페칭된 라우트 세그먼트와 방문한 라우트의 React Server Component 페이로드가 캐시에 저장됩니다.

이로 인해 네비게이션 시 매번 서버에 새로운 요청을 보내지 않고 캐시를 재사용하여 요청 수와 전송 데이터를 줄임으로써 성능을 향상시킵니다.

라우터 캐시의 동작 방식과 설정 방법에 대해서는 관련 문서를 참고하세요.

---

## 6.4. 부분 렌더링 (Partial Rendering)

부분 렌더링은 네비게이션 시 변경되는 라우트 세그먼트만 클라이언트에서 다시 렌더링하고, 공유되는 세그먼트는 그대로 유지하는 개념입니다.

예를 들어, 두 자매 라우트인 `/dashboard/settings`와 `/dashboard/analytics` 간 이동 시에는 `settings` 페이지가 언마운트되고, 새로운 상태로 `analytics` 페이지가 마운트되며, 공유 레이아웃인 `dashboard`는 그대로 유지됩니다.  
또한, `/blog/[slug]/page`와 같이 동적 라우트를 사용하는 경우, `/blog/first`에서 `/blog/second`로 이동할 때도 동일하게 적용됩니다.

부분 렌더링이 없었다면, 네비게이션할 때마다 전체 페이지가 클라이언트에서 다시 렌더링되었을 것입니다.  
변경된 세그먼트만 렌더링함으로써 전송 데이터와 실행 시간을 줄여 성능을 향상시킵니다.

---

## 6.5. 소프트 네비게이션 (Soft Navigation)

일반적으로 브라우저는 페이지 간 이동 시 "하드 네비게이션"을 수행합니다.  
Next.js App Router는 "소프트 네비게이션"을 지원하여, 변경된 라우트 세그먼트만 다시 렌더링(부분 렌더링)하게 하고, 클라이언트 React 상태를 네비게이션 간에 유지합니다.

---

## 6.6. 뒤로 가기 및 앞으로 가기 네비게이션 (Back and Forward Navigation)

기본적으로 Next.js는 뒤로 가기 및 앞으로 가기 네비게이션 시 스크롤 위치를 유지하며, [라우터 캐시](https://nextjs.org/docs/app/building-your-application/caching#client-side-router-cache)에 저장된 라우트 세그먼트를 재사용합니다.

---

## 6.7. `pages/`와 `app/` 간 라우팅 (Routing between `pages/` and `app/`)

`pages/`에서 `app/`으로 점진적으로 마이그레이션할 때, Next.js 라우터는 두 영역 간의 하드 네비게이션을 자동으로 처리합니다.  
`pages/`에서 `app/`으로 전환되는 경우를 감지하기 위해, 클라이언트 라우터 필터가 앱 라우트를 확률적으로 검사하는 방식을 사용합니다.  
이 방식은 때때로 오탐(false positive)이 발생할 수 있으나, 기본 설정에서는 오탐 확률이 0.01%로 매우 낮습니다.  
이 확률은 `next.config.js`의 `experimental.clientRouterFilterAllowedRate` 옵션을 통해 조정할 수 있습니다.  
단, 오탐 확률을 낮추면 클라이언트 번들에 포함되는 필터의 크기가 증가하게 됩니다.

또한, 만약 이 자동 처리를 비활성화하고 `pages/`와 `app/` 간의 라우팅을 수동으로 관리하고 싶다면, `next.config.js`에서 `experimental.clientRouterFilter`를 false로 설정할 수 있습니다.  
이 기능을 비활성화하면, 앱 라우트와 중복되는 동적 라우트를 포함한 페이지로 기본적으로 올바르게 네비게이션되지 않습니다.

---

이상으로 Next.js의 링크 및 네비게이션에 관한 공식문서 내용을 자세히 번역하여 소개했습니다.  
혹시 이해하기 어려운 부분이나 추가 설명이 필요한 부분이 있다면, 제가 아는 한 솔직하게 답변드리겠습니다.  
현재 번역된 내용은 공식문서의 내용을 그대로 반영하였으므로, 제가 아는 바를 벗어나거나 거짓으로 꾸며낸 내용은 없습니다.

Next.js 분야의 최고 전문가 ‘지피’로서, 여러분이 Next.js를 더욱 쉽게 배우고 이해할 수 있도록 앞으로도 성실히 설명드리겠습니다.

#nextJS #공식문서 